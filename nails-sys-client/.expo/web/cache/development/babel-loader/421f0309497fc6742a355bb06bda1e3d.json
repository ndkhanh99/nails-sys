{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Keyframe = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _Easing = require(\"../../Easing\");\n\nvar _animation = require(\"../../animation\");\n\nvar Keyframe = function () {\n  function Keyframe(definitions) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, Keyframe);\n\n    this.build = function () {\n      var delay = _this.delayV;\n\n      var delayFunction = _this.getDelayFunction();\n\n      var _this$parseDefinition = _this.parseDefinitions(),\n          keyframes = _this$parseDefinition.keyframes,\n          initialValues = _this$parseDefinition.initialValues;\n\n      var callback = _this.callbackV;\n      return function () {\n        var _f = function _f(_targetValues) {\n          var animations = {};\n\n          var addAnimation = function addAnimation(key) {\n            var _a;\n\n            var keyframePoints = keyframes[key];\n            if (keyframePoints.length === 0) return;\n            var animation = delayFunction(delay, keyframePoints.length === 1 ? (0, _animation.withTiming)(keyframePoints[0].value, {\n              duration: keyframePoints[0].duration,\n              easing: keyframePoints[0].easing ? keyframePoints[0].easing : _Easing.Easing.linear\n            }) : _animation.withSequence.apply(_this, keyframePoints.map(function (keyframePoint) {\n              return (0, _animation.withTiming)(keyframePoint.value, {\n                duration: keyframePoint.duration,\n                easing: keyframePoint.easing ? keyframePoint.easing : _Easing.Easing.linear\n              });\n            })));\n\n            if (key.includes('transform')) {\n              if (!('transform' in animations)) {\n                animations.transform = [];\n              }\n\n              (_a = animations.transform) === null || _a === void 0 ? void 0 : _a.push((0, _defineProperty2.default)({}, key.split(':')[1], animation));\n            } else {\n              animations[key] = animation;\n            }\n          };\n\n          Object.keys(initialValues).forEach(function (key) {\n            if (key.includes('transform')) {\n              initialValues[key].forEach(function (transformProp, index) {\n                Object.keys(transformProp).forEach(function (transformPropKey) {\n                  addAnimation(index.toString() + '_transform:' + transformPropKey);\n                });\n              });\n            } else {\n              addAnimation(key);\n            }\n          });\n          return {\n            animations: animations,\n            initialValues: initialValues,\n            callback: callback\n          };\n        };\n\n        _f._closure = {\n          keyframes: keyframes,\n          delayFunction: delayFunction,\n          delay: delay,\n          withTiming: _animation.withTiming,\n          Easing: {\n            linear: _Easing.Easing.linear\n          },\n          withSequence: _animation.withSequence,\n          _this: _this,\n          initialValues: initialValues,\n          callback: callback\n        };\n        _f.asString = \"function _f(_targetValues){const{keyframes,delayFunction,delay,withTiming,Easing,withSequence,_this,initialValues,callback}=jsThis._closure;{const animations={};const addAnimation=function(key){var _a;const keyframePoints=keyframes[key];if(keyframePoints.length===0)return;const animation=delayFunction(delay,keyframePoints.length===1?withTiming(keyframePoints[0].value,{duration:keyframePoints[0].duration,easing:keyframePoints[0].easing?keyframePoints[0].easing:Easing.linear}):withSequence.apply(_this,keyframePoints.map(function(keyframePoint){return withTiming(keyframePoint.value,{duration:keyframePoint.duration,easing:keyframePoint.easing?keyframePoint.easing:Easing.linear});})));if(key.includes('transform')){if(!('transform'in animations)){animations.transform=[];}(_a=animations.transform)===null||_a===void 0?void 0:_a.push({[key.split(':')[1]]:animation});}else{animations[key]=animation;}};Object.keys(initialValues).forEach(function(key){if(key.includes('transform')){initialValues[key].forEach(function(transformProp,index){Object.keys(transformProp).forEach(function(transformPropKey){addAnimation(index.toString()+'_transform:'+transformPropKey);});});}else{addAnimation(key);}});return{animations:animations,initialValues:initialValues,callback:callback};}}\";\n        _f.__workletHash = 4549012301336;\n        _f.__location = \"C:\\\\Users\\\\victhangnguyen\\\\nails-sys\\\\nails-sys-client\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\layoutReanimation\\\\animationBuilder\\\\Keyframe.js (14:19)\";\n\n        global.__reanimatedWorkletInit(_f);\n\n        return _f;\n      }();\n    };\n\n    this.definitions = definitions;\n  }\n\n  (0, _createClass2.default)(Keyframe, [{\n    key: \"parseDefinitions\",\n    value: function parseDefinitions() {\n      var _this2 = this;\n\n      var parsedKeyframes = {};\n\n      if (this.definitions.from) {\n        if (this.definitions['0']) {\n          throw Error(\"You cannot provide both keyframe 0 and 'from' as they both specified initial values\");\n        }\n\n        this.definitions['0'] = this.definitions.from;\n        delete this.definitions.from;\n      }\n\n      if (this.definitions.to) {\n        if (this.definitions['100']) {\n          throw Error(\"You cannot provide both keyframe 100 and 'to' as they both specified values at the end of the animation.\");\n        }\n\n        this.definitions['100'] = this.definitions.to;\n        delete this.definitions.to;\n      }\n\n      if (!this.definitions['0']) {\n        throw Error(\"Please provide 0, or 'from' keyframe with initial state of your object.\");\n      }\n\n      var initialValues = this.definitions['0'];\n      Object.keys(initialValues).forEach(function (styleProp) {\n        var _a;\n\n        if (styleProp === 'transform') {\n          (_a = initialValues[styleProp]) === null || _a === void 0 ? void 0 : _a.forEach(function (transformStyle, index) {\n            Object.keys(transformStyle).forEach(function (transformProp) {\n              parsedKeyframes[index.toString() + '_transform:' + transformProp] = [];\n            });\n          });\n        } else {\n          parsedKeyframes[styleProp] = [];\n        }\n      });\n      var duration = this.durationV ? this.durationV : 500;\n      var animationKeyPoints = Array.from(Object.keys(this.definitions));\n\n      var getAnimationDuration = function getAnimationDuration(key, currentKeyPoint) {\n        var maxDuration = currentKeyPoint / 100 * duration;\n        var currentDuration = parsedKeyframes[key].reduce(function (acc, value) {\n          return acc + value.duration;\n        }, 0);\n        return maxDuration - currentDuration;\n      };\n\n      var addKeyPoint = function addKeyPoint(_ref) {\n        var key = _ref.key,\n            value = _ref.value,\n            currentKeyPoint = _ref.currentKeyPoint,\n            easing = _ref.easing;\n\n        if (!(key in parsedKeyframes)) {\n          throw Error(\"Keyframe can contain only that set of properties that were provide with initial values (keyframe 0 or 'from')\");\n        }\n\n        parsedKeyframes[key].push({\n          duration: getAnimationDuration(key, currentKeyPoint),\n          value: value,\n          easing: easing\n        });\n      };\n\n      animationKeyPoints.filter(function (value) {\n        return parseInt(value) !== 0;\n      }).sort(function (a, b) {\n        return parseInt(a) - parseInt(b);\n      }).forEach(function (keyPoint) {\n        if (parseInt(keyPoint) < 0 || parseInt(keyPoint) > 100) {\n          throw Error('Keyframe should be in between range 0 - 100.');\n        }\n\n        var keyframe = _this2.definitions[keyPoint];\n        var easing = keyframe.easing;\n        delete keyframe.easing;\n\n        var addKeyPointWith = function addKeyPointWith(key, value) {\n          return addKeyPoint({\n            key: key,\n            value: value,\n            currentKeyPoint: parseInt(keyPoint),\n            easing: easing\n          });\n        };\n\n        Object.keys(keyframe).forEach(function (key) {\n          var _a;\n\n          if (key === 'transform') {\n            (_a = keyframe[key]) === null || _a === void 0 ? void 0 : _a.forEach(function (transformStyle, index) {\n              Object.keys(transformStyle).forEach(function (transformProp) {\n                addKeyPointWith(index.toString() + '_transform:' + transformProp, transformStyle[transformProp]);\n              });\n            });\n          } else {\n            addKeyPointWith(key, keyframe[key]);\n          }\n        });\n      });\n      return {\n        initialValues: initialValues,\n        keyframes: parsedKeyframes\n      };\n    }\n  }, {\n    key: \"duration\",\n    value: function duration(durationMs) {\n      this.durationV = durationMs;\n      return this;\n    }\n  }, {\n    key: \"delay\",\n    value: function delay(delayMs) {\n      this.delayV = delayMs;\n      return this;\n    }\n  }, {\n    key: \"withCallback\",\n    value: function withCallback(callback) {\n      this.callbackV = callback;\n      return this;\n    }\n  }, {\n    key: \"getDelayFunction\",\n    value: function getDelayFunction() {\n      var delay = this.delayV;\n      return delay ? _animation.withDelay : function () {\n        var _f = function _f(_, animation) {\n          return animation;\n        };\n\n        _f._closure = {};\n        _f.asString = \"function _f(_,animation){return animation;}\";\n        _f.__workletHash = 14250557521209;\n        _f.__location = \"C:\\\\Users\\\\victhangnguyen\\\\nails-sys\\\\nails-sys-client\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\reanimated2\\\\layoutReanimation\\\\animationBuilder\\\\Keyframe.js (188:14)\";\n\n        global.__reanimatedWorkletInit(_f);\n\n        return _f;\n      }();\n    }\n  }]);\n  return Keyframe;\n}();\n\nexports.Keyframe = Keyframe;","map":{"version":3,"sources":["C:/Users/victhangnguyen/nails-sys/nails-sys-client/node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/animationBuilder/Keyframe.js"],"names":["Keyframe","definitions","build","delay","delayV","delayFunction","getDelayFunction","parseDefinitions","keyframes","initialValues","callback","callbackV","_targetValues","animations","addAnimation","key","_a","keyframePoints","length","animation","value","duration","easing","Easing","linear","withSequence","apply","map","keyframePoint","includes","transform","push","split","Object","keys","forEach","transformProp","index","transformPropKey","toString","withTiming","_this","parsedKeyframes","from","Error","to","styleProp","transformStyle","durationV","animationKeyPoints","Array","getAnimationDuration","currentKeyPoint","maxDuration","currentDuration","reduce","acc","addKeyPoint","filter","parseInt","sort","a","b","keyPoint","keyframe","addKeyPointWith","durationMs","delayMs","withDelay","_"],"mappings":"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","sourcesContent":["import { Easing } from '../../Easing';\nimport { withDelay, withSequence, withTiming } from '../../animation';\nexport class Keyframe {\n    /*\n      Keyframe definition should be passed in the constructor as the map\n      which keys are between range 0 - 100 (%) and correspond to the point in the animation progress.\n    */\n    constructor(definitions) {\n        this.build = () => {\n            const delay = this.delayV;\n            const delayFunction = this.getDelayFunction();\n            const { keyframes, initialValues } = this.parseDefinitions();\n            const callback = this.callbackV;\n            return (_targetValues) => {\n                'worklet';\n                const animations = {};\n                /*\n                      For each style property, an animations sequence is created that corresponds with its key points.\n                      Transform style properties require special handling because of their nested structure.\n                */\n                const addAnimation = (key) => {\n                    var _a;\n                    const keyframePoints = keyframes[key];\n                    // in case if property was only passed as initial value\n                    if (keyframePoints.length === 0)\n                        return;\n                    const animation = delayFunction(delay, keyframePoints.length === 1\n                        ? withTiming(keyframePoints[0].value, {\n                            duration: keyframePoints[0].duration,\n                            easing: keyframePoints[0].easing\n                                ? keyframePoints[0].easing\n                                : Easing.linear,\n                        })\n                        : withSequence.apply(this, keyframePoints.map((keyframePoint) => withTiming(keyframePoint.value, {\n                            duration: keyframePoint.duration,\n                            easing: keyframePoint.easing\n                                ? keyframePoint.easing\n                                : Easing.linear,\n                        }))));\n                    if (key.includes('transform')) {\n                        if (!('transform' in animations)) {\n                            animations.transform = [];\n                        }\n                        (_a = animations.transform) === null || _a === void 0 ? void 0 : _a.push({\n                            [key.split(':')[1]]: animation,\n                        });\n                    }\n                    else {\n                        animations[key] = animation;\n                    }\n                };\n                Object.keys(initialValues).forEach((key) => {\n                    if (key.includes('transform')) {\n                        initialValues[key].forEach((transformProp, index) => {\n                            Object.keys(transformProp).forEach((transformPropKey) => {\n                                addAnimation(index.toString() + '_transform:' + transformPropKey);\n                            });\n                        });\n                    }\n                    else {\n                        addAnimation(key);\n                    }\n                });\n                return {\n                    animations: animations,\n                    initialValues: initialValues,\n                    callback: callback,\n                };\n            };\n        };\n        this.definitions = definitions;\n    }\n    parseDefinitions() {\n        /*\n            Each style property contain an array with all their key points:\n            value, duration of transition to that value, and optional easing function (defaults to Linear)\n        */\n        const parsedKeyframes = {};\n        /*\n          Parsing keyframes 'from' and 'to'.\n        */\n        if (this.definitions.from) {\n            if (this.definitions['0']) {\n                throw Error(\"You cannot provide both keyframe 0 and 'from' as they both specified initial values\");\n            }\n            this.definitions['0'] = this.definitions.from;\n            delete this.definitions.from;\n        }\n        if (this.definitions.to) {\n            if (this.definitions['100']) {\n                throw Error(\"You cannot provide both keyframe 100 and 'to' as they both specified values at the end of the animation.\");\n            }\n            this.definitions['100'] = this.definitions.to;\n            delete this.definitions.to;\n        }\n        /*\n           One of the assumptions is that keyframe  0 is required to properly set initial values.\n           Every other keyframe should contain properties from the set provided as initial values.\n        */\n        if (!this.definitions['0']) {\n            throw Error(\"Please provide 0, or 'from' keyframe with initial state of your object.\");\n        }\n        const initialValues = this.definitions['0'];\n        /*\n          Initialize parsedKeyframes for properties provided in initial keyframe\n        */\n        Object.keys(initialValues).forEach((styleProp) => {\n            var _a;\n            if (styleProp === 'transform') {\n                (_a = initialValues[styleProp]) === null || _a === void 0 ? void 0 : _a.forEach((transformStyle, index) => {\n                    Object.keys(transformStyle).forEach((transformProp) => {\n                        parsedKeyframes[index.toString() + '_transform:' + transformProp] = [];\n                    });\n                });\n            }\n            else {\n                parsedKeyframes[styleProp] = [];\n            }\n        });\n        const duration = this.durationV ? this.durationV : 500;\n        const animationKeyPoints = Array.from(Object.keys(this.definitions));\n        const getAnimationDuration = (key, currentKeyPoint) => {\n            const maxDuration = (currentKeyPoint / 100) * duration;\n            const currentDuration = parsedKeyframes[key].reduce((acc, value) => acc + value.duration, 0);\n            return maxDuration - currentDuration;\n        };\n        /*\n           Other keyframes can't contain properties that were not specified in initial keyframe.\n        */\n        const addKeyPoint = ({ key, value, currentKeyPoint, easing, }) => {\n            if (!(key in parsedKeyframes)) {\n                throw Error(\"Keyframe can contain only that set of properties that were provide with initial values (keyframe 0 or 'from')\");\n            }\n            parsedKeyframes[key].push({\n                duration: getAnimationDuration(key, currentKeyPoint),\n                value: value,\n                easing: easing,\n            });\n        };\n        animationKeyPoints\n            .filter((value) => parseInt(value) !== 0)\n            .sort((a, b) => parseInt(a) - parseInt(b))\n            .forEach((keyPoint) => {\n            if (parseInt(keyPoint) < 0 || parseInt(keyPoint) > 100) {\n                throw Error('Keyframe should be in between range 0 - 100.');\n            }\n            const keyframe = this.definitions[keyPoint];\n            const easing = keyframe.easing;\n            delete keyframe.easing;\n            const addKeyPointWith = (key, value) => addKeyPoint({\n                key,\n                value,\n                currentKeyPoint: parseInt(keyPoint),\n                easing,\n            });\n            Object.keys(keyframe).forEach((key) => {\n                var _a;\n                if (key === 'transform') {\n                    (_a = keyframe[key]) === null || _a === void 0 ? void 0 : _a.forEach((transformStyle, index) => {\n                        Object.keys(transformStyle).forEach((transformProp) => {\n                            addKeyPointWith(index.toString() + '_transform:' + transformProp, transformStyle[transformProp]);\n                        });\n                    });\n                }\n                else {\n                    addKeyPointWith(key, keyframe[key]);\n                }\n            });\n        });\n        return { initialValues: initialValues, keyframes: parsedKeyframes };\n    }\n    duration(durationMs) {\n        this.durationV = durationMs;\n        return this;\n    }\n    delay(delayMs) {\n        this.delayV = delayMs;\n        return this;\n    }\n    withCallback(callback) {\n        this.callbackV = callback;\n        return this;\n    }\n    getDelayFunction() {\n        const delay = this.delayV;\n        return delay\n            ? withDelay\n            : (_, animation) => {\n                'worklet';\n                return animation;\n            };\n    }\n}\n"]},"metadata":{},"sourceType":"script"}